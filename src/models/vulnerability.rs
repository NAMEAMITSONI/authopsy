use serde::{Deserialize, Serialize};
use std::fmt;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

impl Severity {
    pub fn numeric_value(&self) -> u8 {
        match self {
            Severity::Critical => 5,
            Severity::High => 4,
            Severity::Medium => 3,
            Severity::Low => 2,
            Severity::Info => 1,
        }
    }
}

impl fmt::Display for Severity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            Severity::Critical => "CRITICAL",
            Severity::High => "HIGH",
            Severity::Medium => "MEDIUM",
            Severity::Low => "LOW",
            Severity::Info => "INFO",
        };
        write!(f, "{}", s)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum VulnType {
    BrokenAccessControl,
    VerticalPrivilegeEscalation,
    HorizontalPrivilegeEscalation,
    DataLeakage,
    SensitiveDataExposure,
    MissingAuthentication,
    InconsistentAuth,
    RoleConfusion,
    PaginationBypass,
    TimingAttack,
    InfoDisclosure,
}

impl fmt::Display for VulnType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            VulnType::BrokenAccessControl => "Broken Access Control",
            VulnType::VerticalPrivilegeEscalation => "Vertical Privilege Escalation",
            VulnType::HorizontalPrivilegeEscalation => "Horizontal Privilege Escalation",
            VulnType::DataLeakage => "Data Leakage",
            VulnType::SensitiveDataExposure => "Sensitive Data Exposure",
            VulnType::MissingAuthentication => "Missing Authentication",
            VulnType::InconsistentAuth => "Inconsistent Authentication",
            VulnType::RoleConfusion => "Role Confusion",
            VulnType::PaginationBypass => "Pagination Bypass",
            VulnType::TimingAttack => "Timing Attack Vector",
            VulnType::InfoDisclosure => "Information Disclosure",
        };
        write!(f, "{}", s)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub severity: Severity,
    pub vuln_type: VulnType,
    pub description: String,
    pub evidence: Evidence,
}

impl Vulnerability {
    pub fn new(severity: Severity, vuln_type: VulnType, description: impl Into<String>, evidence: Evidence) -> Self {
        Self {
            severity,
            vuln_type,
            description: description.into(),
            evidence,
        }
    }

    pub fn critical(vuln_type: VulnType, description: impl Into<String>, evidence: Evidence) -> Self {
        Self::new(Severity::Critical, vuln_type, description, evidence)
    }

    pub fn high(vuln_type: VulnType, description: impl Into<String>, evidence: Evidence) -> Self {
        Self::new(Severity::High, vuln_type, description, evidence)
    }

    pub fn medium(vuln_type: VulnType, description: impl Into<String>, evidence: Evidence) -> Self {
        Self::new(Severity::Medium, vuln_type, description, evidence)
    }

    pub fn low(vuln_type: VulnType, description: impl Into<String>, evidence: Evidence) -> Self {
        Self::new(Severity::Low, vuln_type, description, evidence)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Evidence {
    pub evidence_type: EvidenceType,
    pub details: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EvidenceType {
    StatusMatrix,
    LengthComparison,
    KeyComparison,
    ExtraKeys,
    SensitiveFields,
    ArrayLengths,
    TimingDifference,
    ErrorMessage,
}

impl Evidence {
    pub fn status_matrix(admin: u16, user: u16, anon: u16) -> Self {
        Self {
            evidence_type: EvidenceType::StatusMatrix,
            details: format!("Admin: {}, User: {}, Anon: {}", admin, user, anon),
        }
    }

    pub fn length_comparison(admin_len: usize, user_len: usize, diff_ratio: f64) -> Self {
        Self {
            evidence_type: EvidenceType::LengthComparison,
            details: format!(
                "Admin: {} bytes, User: {} bytes, Difference: {:.2}%",
                admin_len,
                user_len,
                diff_ratio * 100.0
            ),
        }
    }

    pub fn key_comparison(admin_keys: &[String], user_keys: &[String]) -> Self {
        Self {
            evidence_type: EvidenceType::KeyComparison,
            details: format!(
                "Admin keys: {}, User keys: {}",
                admin_keys.len(),
                user_keys.len()
            ),
        }
    }

    pub fn extra_keys(keys: &[&String]) -> Self {
        let key_list: Vec<&str> = keys.iter().take(10).map(|k| k.as_str()).collect();
        Self {
            evidence_type: EvidenceType::ExtraKeys,
            details: format!("Extra keys in User response: {:?}", key_list),
        }
    }

    pub fn sensitive_fields(fields: &[&String]) -> Self {
        let field_list: Vec<&str> = fields.iter().take(10).map(|f| f.as_str()).collect();
        Self {
            evidence_type: EvidenceType::SensitiveFields,
            details: format!("Sensitive fields exposed: {:?}", field_list),
        }
    }

    pub fn array_lengths(path: &str, admin_len: usize, user_len: usize) -> Self {
        Self {
            evidence_type: EvidenceType::ArrayLengths,
            details: format!(
                "Array '{}': Admin sees {} items, User sees {} items",
                path, admin_len, user_len
            ),
        }
    }

    pub fn timing_difference(admin_ms: u64, user_ms: u64) -> Self {
        Self {
            evidence_type: EvidenceType::TimingDifference,
            details: format!("Admin: {}ms, User: {}ms", admin_ms, user_ms),
        }
    }
}
